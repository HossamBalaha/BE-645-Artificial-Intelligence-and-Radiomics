'''
========================================================================
        ╦ ╦┌─┐┌─┐┌─┐┌─┐┌┬┐  ╔╦╗┌─┐┌─┐┌┬┐┬ ┬  ╔╗ ┌─┐┬  ┌─┐┬ ┬┌─┐
        ╠═╣│ │└─┐└─┐├─┤│││  ║║║├─┤│ ┬ ││└┬┘  ╠╩╗├─┤│  ├─┤├─┤├─┤
        ╩ ╩└─┘└─┘└─┘┴ ┴┴ ┴  ╩ ╩┴ ┴└─┘─┴┘ ┴   ╚═╝┴ ┴┴─┘┴ ┴┴ ┴┴ ┴
========================================================================
# Author: Hossam Magdy Balaha
# Initial Creation Date: Feb 25th, 2025
# Last Modification Date: Feb 25th, 2025
# Permissions and Citation: Refer to the README file.
'''

# Import necessary libraries.
import os
import trimesh
import numpy as np
from medmnist import AdrenalMNIST3D


def ShapeFeatures3D(volume):
  """
  Calculate 3D shape features of a given binary or labeled volume.
  The function computes various geometric and topological properties such as volume,
  surface area, compactness, sphericity, elongation, flatness, rectangularity,
  spherical disproportion, and Euler number. These features are derived from the
  mesh representation of the input volume using marching cubes.

  Args:
    volume (numpy.ndarray): A 3D binary or labeled matrix representing the object.

  Returns:
    dict: A dictionary containing the calculated 3D shape features.
  """

  # Converts an (n, m, p) matrix into a mesh, using marching_cubes.
  # Marching cubes algorithm generates a triangular mesh from the volume data.
  mesh = trimesh.voxel.ops.matrix_to_marching_cubes(volume)

  # 1. Volume.
  # Computes the total number of non-zero voxels in the volume.
  volume = np.sum(volume)

  # 2. Surface Area.
  # Calculates the total surface area of the mesh generated by marching cubes.
  surfaceArea = mesh.area

  # 3. Surface to Volume Ratio.
  # Measures the ratio of surface area to volume, indicating compactness.
  surfaceToVolumeRatio = surfaceArea / volume

  # 4. Compactness.
  # Quantifies how closely the shape resembles a sphere, based on volume and surface area.
  compactness = (volume ** (2 / 3)) / (6 * np.sqrt(np.pi) * surfaceArea)

  # 5. Sphericity.
  # Measures how spherical the shape is, normalized by volume and surface area.
  sphericity = (np.pi ** (1 / 3)) * ((6 * volume) ** (2 / 3)) / surfaceArea

  # Bounding Box.
  # Computes the bounding box of the mesh and extracts its dimensions.
  bbox = mesh.bounding_box.bounds
  Lmax = np.max(bbox[1] - bbox[0])  # Maximum length of the bounding box.
  Lmin = np.min(bbox[1] - bbox[0])  # Minimum length of the bounding box.
  Lint = np.median(bbox[1] - bbox[0])  # Intermediate length of the bounding box.

  # 6. Elongation.
  # Measures the ratio of the longest dimension to the shortest dimension of the bounding box.
  elongation = Lmax / Lmin

  # 7. Flatness.
  # Measures the ratio of the shortest dimension to the intermediate dimension of the bounding box.
  flatness = Lmin / Lint

  # 8. Rectangularity.
  # Measures how efficiently the shape fills its bounding box, as the ratio of volume to bounding box volume.
  bboxVolume = np.prod(bbox[1] - bbox[0])  # Volume of the bounding box.
  rectangularity = volume / bboxVolume

  # 9. Euler Number.
  # Represents the topological characteristic of the shape, computed from the mesh.
  eulerNumber = mesh.euler_number

  # Return all calculated features as a dictionary.
  return {
    "Volume"                 : volume,
    "Surface Area"           : surfaceArea,
    "Surface to Volume Ratio": surfaceToVolumeRatio,
    "Compactness"            : compactness,
    "Sphericity"             : sphericity,
    "Elongation"             : elongation,
    "Flatness"               : flatness,
    "Rectangularity"         : rectangularity,
    "Euler Number"           : eulerNumber
  }


valDataset = AdrenalMNIST3D(split="val", download=True)

print("Number of samples in the validation set:", len(valDataset))
print("Sample shape:", valDataset[0][0][0].shape)
print("Maximum value in the sample:", np.max(valDataset[0][0][0]))
print("Minimum value in the sample:", np.min(valDataset[0][0][0]))

# Load the first sample from the validation dataset.
sampleVolume = valDataset[0][0][0]
sampleVolume = (
  (sampleVolume - np.min(sampleVolume)) /
  (np.max(sampleVolume) - np.min(sampleVolume))
)  # Normalize the volume.
sampleVolume = sampleVolume.astype(np.uint8)  # Convert to uint8 type.

# Extract shape features from the preprocessed volume.
shapeFeatures = ShapeFeatures3D(sampleVolume)

# Print the shape features.
# Print the calculated shape features.
print("Shape Features:")
for feature, value in shapeFeatures.items():
  print(f"{feature}: {value:0.4f}")

# Create a 3D mesh from the preprocessed volume data.
mesh = trimesh.voxel.ops.matrix_to_marching_cubes(sampleVolume)

# Set a uniform color for the mesh (e.g., light gray).
mesh.visual.face_colors = [192, 192, 192, 255]  # RGBA: Light gray with full opacity

# Enable smooth shading for better visualization.
mesh = mesh.smoothed()

# Create a scene object to hold the mesh.
scene = mesh.scene()

# Add directional lighting to the scene.
scene.camera_transform = scene.camera.look_at(
  points=mesh.vertices,
  center=mesh.centroid,
  distance=mesh.extents.max() * 2  # Camera distance based on mesh size
)

# Visualize the 3D mesh using trimesh.
scene.show(resolution=(500, 500))
